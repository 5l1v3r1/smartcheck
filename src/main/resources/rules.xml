<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Rules xmlns="http://www.smartdec.ru/SmartCheck/Conditions" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.smartdec.ru/SmartCheck/Conditions rules-grammar-schema.xsd ">
    <Rule>
        <RuleId>SOLIDITY_BALANCE_EQUALITY</RuleId>
        <Patterns>
            <!-- фиксирует конструкцию: "this.balance=="-->
            <Pattern patternId="5094ad">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>//expression[expression//environmentalVariableDefinition[matches(text()[1],"^this.balance$")]][matches(text()[1],"^==$")]</XPath>
            </Pattern>
            <!-- фиксирует конструкцию: "this.balance!="-->
            <Pattern patternId="58a5bd">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>//expression[expression//environmentalVariableDefinition[matches(text()[1],"^this.balance$")]][matches(text()[1],"^!=$")]</XPath>
            </Pattern>
        </Patterns>
    </Rule>

    <Rule>
        <RuleId>SOLIDITY_BYTES_BYTE</RuleId>
        <Patterns>
            <!-- фиксирует конструкцию: "byte[]"-->
            <Pattern patternId="f13a9f">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>//typeName[typeName/elementaryTypeName[text()[1]="byte"]][matches(text()[1],"^\[.*\]$")]</XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_CALL_VALUE</RuleId>
        <Patterns>
            <!-- фиксирует конструкцию: "call.value()()"-->
            <Pattern patternId="cc2e04">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>3</Severity>
                <XPath>//externalFunctionCall/externalFunctionCallNotThis/functionNameAndArgs[functionName/identifier[matches(text()[1],"^call$")] and functionName/identifier[matches(text()[1],"^value$")] and not(callArguments/callArgument)]</XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_DOS_WITH_THROW</RuleId>
        <Patterns>
            <!-- пока отключаем -->
            <!-- фиксирует конструкцию: "if (... внешний вызов ...) {throw, revert}"-->
            <!-- <Pattern patternId="637fdc">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>3</Severity>
                <XPath>//ifStatement[ifCondition//externalFunctionCall][block/statement//throwRevertStatement]</XPath>
            </Pattern> -->
            <!-- пока отключаем -->
            <!-- фиксирует конструкцию: "for (... внешний вызов ...)"-->
            <!-- <Pattern patternId="efb788">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>//forStatement/expression//externalFunctionCall</XPath>
            </Pattern> -->
            <!-- пока отключаем -->
            <!-- фиксирует конструкцию: "while (... внешний вызов ...)"-->
            <!-- <Pattern patternId="04242c">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>//whileStatement/whileCondition//externalFunctionCall</XPath>
            </Pattern> -->
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_ERC20_TRANSFER_SHOULD_THROW</RuleId>
        <Patterns>
            <!--Фиксирует конструкции: имя контракта содержит token или erc20 либо наследуется от контракта содержащего такое в названии.
             В этом контракте есть определение функции, содержащей в названии transfer или transferFrom, возвращающей значение типа bool, которая не является интерфейсом.
             В определении этой функции не содержатся функции revert, require, assert, throw-->
            <Pattern patternId="550a42">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath> //contractDefinition[identifier[matches(text()[1],"token|erc20","i")] or inheritanceSpecifier/userDefinedTypeName/identifier[matches(text()[1],"token|erc20","i")]]
                    //functionDefinition[block/statement][identifier[matches(text()[1],"^transfer(From)?$","i")]][returnsParameters/parameterList/parameter/typeName/elementaryTypeName[matches(text()[1],"bool")]]
                    [count(descendant-or-self::*[functionCall[internalFunctionCall/functionName/identifier
                    [matches(text()[1],"require|assert")]]] | descendant-or-self::*[statement/throwRevertStatement])=0]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_ERC20_APPROVE</RuleId>
        <Patterns>
            <!--Фиксирует конструкции: имя контракта содержит token или erc20 либо наследуется от контракта содержащего такое в названии. В этом контракте есть определение функции approve, которая не является интерфейсом-->
            <Pattern patternId="af782c">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath> //contractDefinition[identifier[matches(text()[1],"token|erc20","i")] or inheritanceSpecifier/userDefinedTypeName/identifier[matches(text()[1],"token|erc20","i")]]
                    //functionDefinition[block/statement][identifier[matches(text()[1],"^approve$","i")]]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_ERC20_TRANSFER_RETURN_FALSE</RuleId>
        <Patterns>
            <!--Фиксирует конструкции: имя контракта содержит token или erc20 либо наследуется от контракта содержащего такое в названии.
            В этом контракте есть определение функции, содержащей в названии transfer или transferFrom, возвращающей значение типа bool, которая не является интерфейсом.
            В определении этой функции не содержит return false или return идентификатор-->
            <Pattern patternId="b180ca">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
            <XPath>
                //contractDefinition[identifier[matches(text()[1],"token|erc20","i")]  or inheritanceSpecifier/userDefinedTypeName/identifier[matches(text()[1],"token|erc20","i")]]
                //functionDefinition[block/statement][identifier[matches(text()[1],"^transfer(From)?$","i")]][returnsParameters/parameterList/parameter/typeName/elementaryTypeName[matches(text()[1],"bool")]][count(descendant-or-self::*[returnStatement/expression/primaryExpression[booleanLiteral[matches(text()[1],"false")] or identifier]])=0]
            </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_GAS_LIMIT_AND_LOOPS</RuleId>
        <Patterns>
            <!--Фиксируется конструкция: for (...;...вызов функции или переменная) или for (переменная цикла равна expression; ... ; ...)-->
            <Pattern patternId="f6f853">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>//forStatement[expression[1]/expression[2][functionCall or primaryExpression/identifier] or simpleStatement/variableDeclarationStatement/variableDeclaration/expression]</XPath>
            </Pattern>
            <!--Фиксируется конструкция: while (в условии используется вызов функции)-->
            <Pattern patternId="38f6c7">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>//whileStatement[whileCondition/descendant::*[functionCall]]</XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_INTEGER_DIVISION</RuleId>
        <Patterns>
            <!-- пока отключаем -->
            <!--Фиксируется конструкция: целое число / целое число-->
            <!-- <Pattern patternId="8e0621">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>//expression[expression[1]//numberLiteral][muldivOperator/divOperator][expression[2]//numberLiteral]</XPath>
            </Pattern> -->
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_LOCKED_MONEY</RuleId>
        <Patterns>
            <!--Фиксируются ситуации, когда в контракте имеется функция типа payable, но нет функций suicide, selfdestruct, transfer, send, .value-->
            <Pattern patternId="30281d">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>//contractDefinition[contractPartDefinition//functionDefinition/stateMutability/payableType]
                    [not(contractPartDefinition/functionDefinition/block//functionCall/internalFunctionCall/functionName/identifier[matches(text()[1],"^suicide|selfdestruct$")])]
                    [not(contractPartDefinition/functionDefinition/block//functionCall/externalFunctionCall/externalFunctionCallNotThis/functionNameAndArgs/functionName/identifier[matches(text()[1],"^transfer|send$")])]
                    [not(contractPartDefinition/functionDefinition/block//functionCall/externalFunctionCall/externalFunctionCallNotThis/functionNameAndArgs/functionName/identifier[text()[1]="value"])]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_MALICIOUS_LIBRARIES</RuleId>
        <Patterns>
            <!-- пока отключаем -->
            <!--Фиксируется любое определение библиотек-->
            <!-- <Pattern patternId="a0298c">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>//contractDefinition[text()[1]="library"]</XPath>
            </Pattern> -->
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_PRAGMAS_VERSION</RuleId>
        <Patterns>
            <!--Фиксируется определение pragma имеющее в версии знаки '^' | '>=' | '>' | '<' | '<='-->
            <Pattern patternId="23fc32">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>//pragmaDirective/pragmaValue//versionOperator</XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_PRIVATE_MODIFIER</RuleId>
        <Patterns>
            <!--Фиксируется определение state переменных с типом видимости private-->
            <Pattern patternId="5616b2">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>//stateVariableDeclaration/visibleType[text()[1]="private"]</XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_REDUNDANT_FALLBACK_REJECT</RuleId>
        <Patterns>
            <!--Фиксируется случаи, когда версия компилятора больше или равна 0.4.0, контракт содержит fallback функцию типа payable, в определении которой есть throw или revert() -->
            <Pattern patternId="b85a32">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>//sourceUnit[pragmaDirective/pragmaValue/version/versionConstraint[versionLiteral &gt;= "0.4.0"]]/contractDefinition/contractPartDefinition/functionFallBackDefinition[stateMutability/payableType][block/statement/throwRevertStatement]</XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_REENTRANCY_EXTERNAL_CALL</RuleId>
        <Patterns>
            <!--Фиксируется случаи, когда внутри определения функции после внешних вызовов есть внутренние-->
            <Pattern patternId="de222d">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>3</Severity>
                <XPath>//contractDefinition[contractPartDefinition/usingForDeclaration[identifier[text()[1]="SafeMath"]]]//functionDefinition//externalFunctionCall[not(externalFunctionCallNotThis/functionNameAndArgs/functionName/identifier[matches(text()[1],"^add|sub|mul|div$")])][ancestor::statement[1]/following-sibling::statement[count(descendant-or-self::*[functionCall/externalFunctionCall[not(externalFunctionCallNotThis/functionNameAndArgs/functionName/identifier[matches(text()[1],"^add|sub|mul|div$")])]])=0]]</XPath>
            </Pattern>
            <!--Фиксируется случаи, когда внутри определения функции после внешних вызовов есть внутренние-->
            <Pattern patternId="252f1c">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>3</Severity>
                <XPath>//contractDefinition[not(contractPartDefinition/usingForDeclaration/identifier[text()[1]="SafeMath"])]//functionDefinition//externalFunctionCall[ancestor::statement[1]/following-sibling::statement[count(descendant-or-self::*[functionCall/externalFunctionCall])=0]]                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_SEND</RuleId>
        <Patterns>
            <!--Фиксируется использование функции send, в случаях: if (..send()){revert() или throw} и require или assert от send-->
            <Pattern patternId="430636">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>3</Severity>
                <XPath>
                    //functionName/identifier[text()[1]="send"][ancestor::ifCondition/parent::*[block//statement/throwRevertStatement] or ancestor::internalFunctionCall/functionName/identifier[matches(text()[1],"^require|assert$")]]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_STYLE_GUIDE_VIOLATION</RuleId>
        <Patterns>
            <!--Фиксируется случаи, event определяется с маленькой буквы-->
            <Pattern patternId="343033">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>0</Severity>
                <XPath>//eventDefinition/identifier[matches(text()[1],"^[a-z]")]</XPath>
            </Pattern>
            <!--Фиксируется случаи, когда функция определяется с большой буквы-->
            <Pattern patternId="b0dbcd">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>0</Severity>
                <XPath>//functionDefinition[identifier[matches(text()[1],"^[A-Z]")]][not(identifier =//ancestor::*/contractDefinition/identifier)]</XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_TIMESTAMP_DEPENDENCE</RuleId>
        <Patterns>
            <!--Фиксируется случаи, когда выражение содержит "== or = block.timestamp or now"-->
            <Pattern patternId="1955d9">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>//expression[matches(text()[1],"^==|!=$") and expression//environmentalVariableDefinition[matches(text()[1],"^block.timestamp|now$")]]</XPath>
            </Pattern>
            <!--Фиксируется случаи, когда в вызове функции в качестве аргусентов передаются block.timestamp или now. А также, когда в выражении используется "= и далее выражение содержащее  block.timestamp или now" -->
            <Pattern patternId="cd1537">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>//statement[simpleStatement//functionCall[internalFunctionCall or externalFunctionCall]//callArguments[ not(callArgument//expression[matches(text()[1],"^>=|>|lt |lt =$")]) and callArgument//expression[environmentalVariableDefinition[matches(text()[1],"^block.timestamp|now$")]]]
                    or simpleStatement/expressionStatement//expression[matches(text()[1],"^=$") and expression//environmentalVariableDefinition[matches(text()[1],"^block.timestamp|now$")]]]</XPath>
            </Pattern>
            <!-- пока отключаем -->
            <!--Фиксируется все вхождения block.timestamp или now-->
            <!-- <Pattern patternId="afb67a">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>0</Severity>
                <XPath>
                    //expression/environmentalVariableDefinition[matches(text()[1],"block.timestamp|now")]/ancestor-or-self::statement
                </XPath>
            </Pattern> -->
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_TX_ORIGIN</RuleId>
        <Patterns>
            <!--Фиксируется вхождение tx.origin-->
            <Pattern patternId="12e802">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>//environmentalVariableDefinition[matches(text()[1],"^tx.origin$")]/parent::*[parent::*[not(matches(text()[1],"^==|!=$") and expression/environmentalVariableDefinition[matches(text()[1],"^msg.sender$")])]]</XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_UNCHECKED_CALL</RuleId>
        <Patterns>
            <!--Фиксируется случаи, когда вызовы функций  call, delegatecall, send, callcode не имеют предков по дереву: if, require, assert, return, вызов функции, не входит в определение переменной-->
            <Pattern patternId="f39eed">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>3</Severity>
                <XPath>//externalFunctionCall/externalFunctionCallNotThis[functionNameAndArgs/functionName/identifier[matches(text()[1],"^call|delegatecall|send|callcode$")] and not(ancestor::ifCondition) and not(ancestor::internalFunctionCall[functionName/identifier[matches(text()[1],"^require|assert$")]]) and not(ancestor::returnStatement) and not(ancestor::functionCall[2]) and not(ancestor::variableDeclarationStatement)]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_VAR</RuleId>
        <Patterns>
            <!--Фиксируется случаи определения переменных, как var ...= число-->
            <Pattern patternId="d28aa7">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>//variableDeclaration[typeName/elementaryTypeName[matches(text()[1],"^var$")]][expression//primaryExpression/numberLiteral[matches(text()[1],"^[0-9]+$")]]</XPath>
            </Pattern>
            <!--Фиксируется случаи определения переменных, как var имя переменной-->
            <Pattern patternId="f77619">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>//variableDeclaration[typeName/elementaryTypeName[matches(text()[1],"^var$")]][expression/primaryExpression/identifier]</XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_VAR_IN_LOOP_FOR</RuleId>
        <Patterns>
            <!-- фиксирует конструкцию: "for (var ...; ... число более 255; ... ++)"-->
            <Pattern patternId="f176ab">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <TruePositiveRate>3</TruePositiveRate>
                <XPath>//forStatement[simpleStatement//typeName/elementaryTypeName[matches(text()[1],"^var$")]][expression/expression/primaryExpression[numberLiteral[matches(text()[1],"^[0-9]+$")]&gt; 255]][expression/twoPlusMinusOperator/incrementOperator]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_VISIBILITY</RuleId>
        <Patterns>
            <!-- фиксирует ситуацию, когда для функции не определена видимость"-->
            <Pattern patternId="910067">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>0</Severity>
                <XPath>//contractPartDefinition/functionDefinition[not(visibleType)]</XPath>
            </Pattern>
            <!-- фиксирует ситуацию, когда для переменной состояния не определена видимость"-->
            <Pattern patternId="b51ce0">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>0</Severity>
                <XPath>//contractPartDefinition/stateVariableDeclaration[not(visibleType)]</XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_VIEW_FUNCTION</RuleId>
        <Patterns>
            <Pattern patternId="189abf">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>0</Severity>
                <!--Writing to state variables - лучше сделать через флаги-->
                <!--Emitting events - лучше сделать через флаги-->
                <!--Creating other contracts - лучше сделать через флаги-->
                <!--Calling any function not marked view or pure:- лучше сделать через флаги-->
                <XPath>
                    //functionDefinition[stateMutability/viewType][
                        <!--Using selfdestruct and it's alias suicide:-->
                        block/statement//functionCall/internalFunctionCall/functionName/identifier[matches(text()[1],"^selfdestruct|suicide$")]
                        <!--Sending Ether via calls:-->
                        or block/statement//functionCall//externalFunctionCallNotThis/functionNameAndArgs/functionName/identifier[matches(text()[1],"^send|transfer$")]
                        <!--Using low-level calls:-->
                        or block/statement//functionCall//externalFunctionCallNotThis/functionNameAndArgs/functionName/identifier[matches(text()[1],"^call|delegatecall|callcode$")]
                        <!--Using inline assembly that contains certain opcodes:-->
                        or block/statement//inlineAssemblyStatement
                    ]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_SHOULD_BE_VIEW_BUT_IS_NOT</RuleId>
        <Patterns>
            <!-- пока отключаем -->
            <!-- <Pattern patternId="ad1827">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>0</Severity>
                <!-Writing to state variables - лучше сделать через флаги ->
                <!-Emitting events - лучше сделать через флаги ->
                <!-Creating other contracts - лучше сделать через флаги ->
                <!-Calling any function not marked view or pure:- лучше сделать через флаги ->

                <XPath>
                    //functionDefinition[not(identifier=//ancestor::*/contractDefinition/identifier)][not(stateMutability/viewType) and not(stateMutability/constantType) and not(stateMutability/pureType)][block][
                        <!-Using selfdestruct and it's alias suicide: ->
                        not(block/statement//functionCall/internalFunctionCall/functionName/identifier[matches(text()[1],"^selfdestruct|suicide$")])
                        <!-Sending Ether via calls: ->
                        and not(block/statement//functionCall//externalFunctionCallNotThis/functionNameAndArgs/functionName/identifier[matches(text()[1],"^send|transfer$")])
                        <!-Using low-level calls: ->
                        and not(block/statement//functionCall//externalFunctionCallNotThis/functionNameAndArgs/functionName/identifier[matches(text()[1],"^call|delegatecall|callcode$")])
                        <!-Using inline assembly that contains certain opcodes: ->
                        and not(block/statement//inlineAssemblyStatement)
                    ]
                </XPath>
            </Pattern> -->
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_PURE_FUNCTION</RuleId>
        <Patterns>
            <Pattern patternId="11314f">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>0</Severity>
                <XPath>
                    //functionDefinition[stateMutability/pureType][
                        <!--Accessing this.balance or <address>.balance: using .balance or this.balance-->
                        block/statement//functionCall//externalFunctionCallNotThis/functionNameAndArgs[matches(text()[1],"^.$")][functionName/identifier[matches(text()[1],"^balance$")]]
                        or //environmentalVariableDefinition[matches(text()[1],"^this.balance$")]
                        <!--Accessing any of the members of block, tx, msg (with the exception of msg.sig and msg.data)-->
                        or //environmentalVariableDefinition[matches(text()[1],"^msg.value|msg.gas|msg.sender|block.timestamp|tx.origin|block.blockhash|block.coinbase|block.difficulty|block.gaslimit|block.number|block.blockhash|block.coinbase|tx.gasprice$")]
                        <!--Using selfdestruct and it's alias suicide:-->
                        or block/statement//functionCall/internalFunctionCall/functionName/identifier[matches(text()[1],"^selfdestruct|suicide$")]
                        <!--Sending Ether via calls:-->
                        or block/statement//functionCall//externalFunctionCallNotThis/functionNameAndArgs/functionName/identifier[matches(text()[1],"^send|transfer$")]
                        <!--Using low-level calls:-->
                        or block/statement//functionCall//externalFunctionCallNotThis/functionNameAndArgs/functionName/identifier[matches(text()[1],"^call|delegatecall|callcode$")]
                        <!--Using inline assembly that contains certain opcodes:-->
                        or block/statement//inlineAssemblyStatement
                    ]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_SHOULD_BE_PURE_BUT_IS_NOT</RuleId>
        <Patterns>
            <!-- пока отключаем -->
            <!-- <Pattern patternId="bca409">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>0</Severity>
                <XPath>
                    //functionDefinition[not(identifier=//ancestor::*/contractDefinition/identifier)][not(stateMutability/pureType) and not(stateMutability/constantType) and not(stateMutability/viewType)][block][
                        <!-Accessing this.balance or <address>.balance: using .balance or this.balance ->
                        not(block/statement//functionCall//externalFunctionCallNotThis/functionNameAndArgs[matches(text()[1],"^.$")][functionName/identifier[matches(text()[1],"^balance$")]])
                        and not(block/statement//environmentalVariableDefinition[matches(text()[1],"^this.balance$")])
                        <!-Accessing any of the members of block, tx, msg (with the exception of msg.sig and msg.data) ->
                        and not(block/statement//environmentalVariableDefinition[matches(text()[1],"^msg.value|msg.gas|msg.sender|block.timestamp|tx.origin|block.blockhash|block.coinbase
                        |block.difficulty|block.gaslimit|block.number|block.blockhash|block.coinbase|tx.gasprice$")])
                        <!-Using selfdestruct and it's alias suicide: ->
                        and not(block/statement//functionCall/internalFunctionCall/functionName/identifier[matches(text()[1],"^selfdestruct|suicide$")])
                        <!-Sending Ether via calls: ->
                        and not(block/statement//functionCall//externalFunctionCallNotThis/functionNameAndArgs/functionName/identifier[matches(text()[1],"^send|transfer$")])
                        <!-Using low-level calls: ->
                        and not(block/statement//functionCall//externalFunctionCallNotThis/functionNameAndArgs/functionName/identifier[matches(text()[1],"^call|delegatecall|callcode$")])
                        <!-Using inline assembly that contains certain opcodes: ->
                        and not(block/statement//inlineAssemblyStatement)
                    ]
                </XPath>
            </Pattern> -->
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_ADDRESS_HARDCODED</RuleId>
            <Patterns>
                <!-- фиксирует адреса длиной в 42 символа"-->
                <Pattern patternId="adc165">
                    <Categories>
                         <Category>Solidity</Category>
                    </Categories>
                    <Severity>1</Severity>
                    <TruePositiveRate>2</TruePositiveRate>
                    <XPath>
                        //addressContract[string-length(addressNumber)=42]
                    </XPath>
                </Pattern>
                <!-- фиксирует адреса длиной менее чем 42 символа и не равные 0x0"-->
                <Pattern patternId="b140cd">
                    <Categories>
                        <Category>Solidity</Category>
                    </Categories>
                    <Severity>1</Severity>
                    <TruePositiveRate>2</TruePositiveRate>
                    <XPath>
                        //addressContract[string-length(addressNumber) lt 42 and not(addressNumber[matches(text()[1],"^0x0$")])]
                    </XPath>
                </Pattern>
                <!-- фиксирует конструкции: address(numberLiteral), где numberLiteral не равно 0"-->
                <Pattern patternId="f32db1">
                    <Categories>
                        <Category>Solidity</Category>
                    </Categories>
                    <Severity>1</Severity>
                    <TruePositiveRate>2</TruePositiveRate>
                    <XPath>
                        //addressCall/expression[primaryExpression/numberLiteral][not(primaryExpression/numberLiteral[matches(text()[1],"^0$")]) and not(primaryExpression/identifier[matches(text()[1],"^this$")])]
                    </XPath>
                </Pattern>
                <!-- фиксирует конструкции: address(0), кроме "!=address(0)", кроме Transfer(address(),...) в контракте, который называется или унаследован от token/erc20-->
                <Pattern patternId="a91b18">
                    <Categories>
                        <Category>Solidity</Category>
                    </Categories>
                    <Severity>1</Severity>
                    <TruePositiveRate>1</TruePositiveRate>
                    <XPath>
                        //expression[addressCall/expression/primaryExpression/numberLiteral[matches(text()[1],"^0$")]]
                        /parent::*[not(matches(text()[1],"^!=$"))][not(ancestor::internalFunctionCall[1]/functionName/identifier[matches(text()[1],"^Transfer$")]/ancestor::contractDefinition[identifier[matches(text()[1],"token|erc20","i")] or inheritanceSpecifier/userDefinedTypeName/identifier[matches(text()[1],"token|erc20","i")]])]
                    </XPath>
                </Pattern>
                <!-- фиксирует использование адреса 0x0, кроме "!=0x0", и кторе тех случаев, когда 0x0 внутри event(внутренняя функция, название которой начинается с большой буквы)-->
                <Pattern patternId="c67a09">
                    <Categories>
                        <Category>Solidity</Category>
                    </Categories>
                    <Severity>1</Severity>
                    <TruePositiveRate>1</TruePositiveRate>
                    <XPath>
                        //addressContract[addressNumber[matches(text()[1],"^0x0$")]]/parent::*[parent::*[parent::*[not(matches(text()[1],"^!=$"))]]][not(ancestor::internalFunctionCall[1]/functionName/identifier[matches(text()[1],"^[A-Z]")])]
                    </XPath>
                </Pattern>
            </Patterns>
    </Rule>

    <Rule>
        <RuleId>SOLIDITY_CONSTANT_FUNCTIONS</RuleId>
        <Patterns>
            <!-- фиксирует использование типа constant в определении функции-->
            <Pattern patternId="28fa69">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>0</Severity>
                <XPath>
                    //functionDefinition[stateMutability/constantType]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_DELETE_FOR_ARRAYS</RuleId>
        <Patterns>
            <!--Фиксирует ... .length=0-->
            <Pattern patternId="792a6d">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //simpleStatement/expressionStatement/expression[expression/environmentalVariableDefinition[matches(text()[1],"length")]][matches(text()[1],"^=$")][expression/primaryExpression/numberLiteral[matches(text()[1],"^0$")]]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_DOS_WITH_REVERT</RuleId>
        <Patterns>
            <!--Фиксирует require(внешний вызов)-->
            <Pattern patternId="15ac23">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                //statement//internalFunctionCall[functionName/identifier[matches(text()[1],"require")]][callArguments/callArgument//functionCall/externalFunctionCall]
            </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_UNCHECKED_MATH</RuleId>
        <Patterns>
            <!--Фиксирует все вхождения decrement, -, -=, ... -->
            <Pattern patternId="87b5ac">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //contractDefinition[not(identifier[matches(text()[1],"SafeMath")])]//expression[last()][descendant-or-self::*[decrementOperator or plusminusOperator[text()[1]="-"] or minusLvalueOperator]]/ancestor-or-self::expression[last()]
                </XPath>
            </Pattern>
            <!--Фиксирует все вхождения /,/=,%,%= -->
            <Pattern patternId="16dca5">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //contractDefinition[not(identifier[matches(text()[1],"SafeMath")])]//expression[last()][descendant-or-self::*[divOperator or divRemOperator or divRemLvalueOperator or divLvalueOperator]]/ancestor-or-self::expression[last()]
                </XPath>
            </Pattern>
            <!-- пока отключаем -->
            <!--Фиксирует все вхождения + с константой,+= с константой, ++,-->
            <!-- <Pattern patternId="50dc28">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>0</Severity>
                <XPath>
                    //contractDefinition[not(identifier[matches(text()[1],"SafeMath")])]//expression[last()][descendant-or-self::*[plusminusOperator[text()[1]="+"]/parent::*[expression/primaryExpression/numberLiteral] or lvalueOperator[plusLvalueOperator]/parent::*[expression/primaryExpression/numberLiteral] or incrementOperator]]/ancestor-or-self::expression[last()]
                </XPath>
            </Pattern> -->
            <!--Фиксирует все вхождения +, += где нет сложения с константой-->
            <Pattern patternId="61c5ab">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //contractDefinition[not(identifier[matches(text()[1],"SafeMath")])]//expression[last()][descendant-or-self::*[plusminusOperator[text()[1]="+"]/parent::*[not(expression/primaryExpression/numberLiteral)] or lvalueOperator[plusLvalueOperator]/parent::*[not(expression/primaryExpression/numberLiteral)]]]/ancestor-or-self::expression[last()]
                </XPath>
            </Pattern>
            <!--Фиксирует все вхождения *,**,*=-->
            <Pattern patternId="7dc23a">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>
                    //contractDefinition[not(identifier[matches(text()[1],"SafeMath")])]//expression[last()][descendant-or-self::*[mulLvalueOperator or powerOperator or mulOperator]]/ancestor-or-self::expression[last()]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>

        <RuleId>SOLIDITY_UNDERFLOW_OVERFLOW</RuleId>
        <Patterns>
            <!--Фиксирует конструкцию: "for (...; i >= 0; ...) { ... }"-->
            <Pattern patternId="11ca45b">
            <Categories>
                <Category>Solidity</Category>
            </Categories>
            <Severity>1</Severity>
            <TruePositiveRate>3</TruePositiveRate>
            <XPath>
                //forStatement/expression[matches(text()[1],">=")][expression/primaryExpression/numberLiteral[matches(text()[1],"^0$")]]
            </XPath>
        </Pattern>
            <!--Фиксирует конструкцию: "...>=0"-->
            <Pattern patternId="d48ac4">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <TruePositiveRate>3</TruePositiveRate>
                <XPath>
                    //expression[matches(text()[1],">=")][expression/primaryExpression/numberLiteral[matches(text()[1],"^0$")]]/ancestor-or-self::statement
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_REVERT_REQUIRE</RuleId>
        <Patterns>
            <!--Фиксирует конструкцию: "if (...){revert(); или throw;}"-->
            <Pattern patternId="c56b12">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <TruePositiveRate>3</TruePositiveRate>
                <XPath>
                    //ifStatement/block/statement/throwRevertStatement/ancestor-or-self::statement[2]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
    <RuleId>SOLIDITY_FUNCTIONS_RETURNS_TYPE_AND_NO_RETURN</RuleId>
    <Patterns>
        <!--Фиксирует конструкцию: "function(...) ... returns (type) {...}" т.е. после type ничего нет и в теле функции нет return-->
        <Pattern patternId="47acc2">
            <Categories>
                <Category>Solidity</Category>
            </Categories>
            <Severity>1</Severity>
            <XPath>
                //functionDefinition[block]/returnsParameters[not(parameterList/parameter/identifier)]/parent::*[not(block/statement//returnStatement)]
            </XPath>
        </Pattern>
    </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_NO_PAYABLE_FALLBACK</RuleId>
        <Patterns>
            <!--Фиксирует ситуацию, когда в fallback функции нет "payable"-->
            <Pattern patternId="86c34a">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //functionFallBackDefinition[not(stateMutability/payableType)]
                </XPath>
            </Pattern>
            <!--Фиксирует ситуацию, когда в контракте нет fallback функции-->
            <Pattern patternId="70ac56">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //contractDefinition[not(contractPartDefinition/functionFallBackDefinition)]
                </XPath>
            </Pattern>
            <!--Фиксирует ситуацию, когда в контракте есть payable fallback функция, которая содержит только throw или только revert()-->
            <Pattern patternId="12fa3c">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //functionFallBackDefinition[stateMutability/payableType]/block[count(descendant-or-self::statement)=1]/statement[throwRevertStatement]/ancestor-or-self::functionFallBackDefinition
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_USING_INLINE_ASSEMBLY</RuleId>
        <Patterns>
            <!--Фиксирует конструкцию: "assembly", кроме конструкции: assembly { ... := extcodesize(...) }-->
            <Pattern patternId="109cd5">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //statement/inlineAssemblyStatement/inlineAssemblyBlock/assemblyStatement[not(assemblyItem/assemblerLocalVariables[matches(text()[1],"^:=$")][functionalAssemblyExpression/identifier[matches(text()[1],"^extcodesize$")]])]/ancestor::inlineAssemblyStatement
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_USING_SHA3</RuleId>
        <Patterns>
            <!--Фиксирует конструкцию: "sha3"-->
            <Pattern patternId="187b5a">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>2</Severity>
                <XPath>
                    //functionName/identifier[matches(text()[1],"^sha3$")]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_USING_SUICIDE</RuleId>
        <Patterns>
            <!--Фиксирует конструкцию: "suicide"-->
            <Pattern patternId="27cb59">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //functionName/identifier[matches(text()[1],"suicide")]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_USING_THROW</RuleId>
        <Patterns>
            <!--Фиксирует конструкцию: "throw"-->
            <Pattern patternId="49bd2a">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //statement/throwRevertStatement[matches(text()[1],"throw")]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
    <Rule>
        <RuleId>SOLIDITY_USING_BLOCKHASH</RuleId>
        <Patterns>
            <!--Фиксирует конструкцию: "blockhash"-->
            <Pattern patternId="b629ad">
                <Categories>
                    <Category>Solidity</Category>
                </Categories>
                <Severity>1</Severity>
                <XPath>
                    //expression[//environmentalVariableDefinition[matches(text()[1],"block.blockhash")]]
                </XPath>
            </Pattern>
        </Patterns>
    </Rule>
</Rules>
